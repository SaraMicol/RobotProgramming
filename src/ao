#include <ros/ros.h>
#include <nav_msgs/OccupancyGrid.h>
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/Twist.h>
#include <nav_msgs/Odometry.h>
#include <yaml-cpp/yaml.h>
#include <tf2_ros/transform_broadcaster.h>
#include <geometry_msgs/TransformStamped.h>
#include <tf2/LinearMath/Quaternion.h>
#include <sensor_msgs/LaserScan.h>
#include <cmath>
#include <vector>
#include <string>
#include <memory>
#include <visualization_msgs/MarkerArray.h>

#include "laser_scan.h"
#include "laser_scanner.h"
#include "grid_map.h"
#include "laser_visualization.h"
#include "robot_config.h"
#include "utils.h"

// Struttura per memorizzare stato goal per ogni robot
struct RobotGoal {
    bool has_goal;
    double goal_x;
    double goal_y;
    
    RobotGoal() : has_goal(false), goal_x(0.0), goal_y(0.0) {}
};

std::vector<RobotGoal> robot_goals;
std::vector<ActiveSensor> active_sensors;

// Dichiarazione forward della funzione
double computeObstacleAvoidance(const RobotConfig& robot, const ActiveSensor& sensor);

// Callback per cmd_vel (override manuale)
void updateCmdVelCallback(const geometry_msgs::Twist::ConstPtr& msg, RobotConfig* robot)
{
    robot->current_v_lin = msg->linear.x;
    robot->current_v_ang = msg->angular.z;
}

// Aggiorna controllo robot verso goal
void updateRobotControl(RobotConfig* robot, RobotGoal* robot_goal)
{
    if (!robot_goal->has_goal) {
        robot->current_v_lin = 0.0;
        robot->current_v_ang = 0.0;
        return;
    }
    
    // Calcola distanza e angolo al goal
    double dx = robot_goal->goal_x - robot->x;
    double dy = robot_goal->goal_y - robot->y;
    double dist = sqrt(dx*dx + dy*dy);
    
    // Soglia di arrivo
    const double GOAL_TOLERANCE = 0.15;
    if (dist < GOAL_TOLERANCE) {
        robot->current_v_lin = 0.0;
        robot->current_v_ang = 0.0;
        robot_goal->has_goal = false;
        ROS_INFO("Robot %s: Goal raggiunto!", robot->id.c_str());
        return;
    }
    
    // Calcola direzione desiderata
    double target_theta = atan2(dy, dx);
    double angle_diff = target_theta - robot->alpha;
    
    // Normalizza angolo tra -PI e PI
    while(angle_diff > M_PI) angle_diff -= 2.0*M_PI;
    while(angle_diff < -M_PI) angle_diff += 2.0*M_PI;
    
    // Parametri di controllo
    const double MAX_LINEAR_VEL = 0.5;   // m/s
    const double MAX_ANGULAR_VEL = 1.0;  // rad/s
    const double ANGULAR_THRESHOLD = 0.3; // rad (~17 gradi)
    
    // Se l'angolo è troppo grande, prima ruota
    if (fabs(angle_diff) > ANGULAR_THRESHOLD) {
        robot->current_v_lin = 0.0;
        robot->current_v_ang = std::min(MAX_ANGULAR_VEL, 
                                       std::max(-MAX_ANGULAR_VEL, 3.0 * angle_diff));
    } else {
        // ========== Aggiunta evitamento ostacoli ==========
        double avoid = 0.0;

        // Trova il laser del robot corrente
        for (const auto& s : active_sensors) {
            if (s.robot_index == robot->index) {
                avoid = computeObstacleAvoidance(*robot, s);
                break;
            }
        }
        
        // ========== Controllo misto goal + evitamento ==========
        double angular = 2.0 * angle_diff + avoid;

        robot->current_v_lin = std::min(MAX_LINEAR_VEL, 0.8 * dist);

        // Rallenta se evita ostacoli
        if (fabs(avoid) > 0.2) {
            robot->current_v_lin *= 0.4;
        }

        robot->current_v_ang = std::min(MAX_ANGULAR_VEL,
                                       std::max(-MAX_ANGULAR_VEL, angular));
    }
}

// Funzione per calcolare evitamento ostacoli basato su laser
double computeObstacleAvoidance(const RobotConfig& robot, const ActiveSensor& sensor)
{
    double avoid_turn = 0.0;
    const double OBSTACLE_THRESHOLD = 0.6;   // distanza minima
    const double TURN_GAIN = 1.2;            // quanto gira per evitare

    const auto& ranges = sensor.laser_scan->ranges;
    int N = ranges.size();
    if (N == 0) return 0.0;

    double angle_increment = 
        (sensor.laser_scan->angle_max - sensor.laser_scan->angle_min) / N;

    for (int i = 0; i < N; i++) {
        float d = ranges[i];
        if (d < OBSTACLE_THRESHOLD && d > 0.01) {  // Ignora letture troppo vicine (rumore)
            // Angolo relativo del laser
            float angle = sensor.laser_scan->angle_min + i * angle_increment;

            // Forza repulsiva (più vicino → maggiore deviazione)
            avoid_turn -= TURN_GAIN * (OBSTACLE_THRESHOLD - d) * sin(angle);
        }
    }
    return avoid_turn;
}

int main(int argc, char** argv) {
    ros::init(argc, argv, "robsim_node");
    ros::NodeHandle nh;

    // Publisher per visualizzazione laser
    ros::Publisher laser_viz_pub = nh.advertise<visualization_msgs::MarkerArray>("laser_visualization", 1);
    
    MapConfig map_cfg;
    std::vector<RobotConfig> robots;

    std::string yaml_file = "/home/lattinone/RobotProgramming/src/ros_2d_multi_robot_simulator/configs/env1.yaml";
    parseYAML(yaml_file, map_cfg, robots);
    
    // Assegna indice a ogni robot
    for (size_t i = 0; i < robots.size(); i++)
        robots[i].index = i;

    auto map_msg = createMap(map_cfg);
    auto grid_map = createGridMap(map_msg);

    ros::Publisher map_pub = nh.advertise<nav_msgs::OccupancyGrid>("/map", 1, true);
    map_msg.header.stamp = ros::Time::now();
    map_msg.header.frame_id = "map";
    map_pub.publish(map_msg);
    ROS_INFO("Mappa pubblicata su /map (%dx%d, resolution=%.3f)", 
             map_msg.info.width, map_msg.info.height, map_msg.info.resolution);

    ros::Duration(0.5).sleep();
    ros::spinOnce();

    // Inizializza goal per ogni robot
    robot_goals.resize(robots.size());

    // Publisher e Subscriber
    std::vector<ros::Publisher> pose_pubs;
    std::vector<ros::Publisher> odom_pubs;
    std::vector<ros::Subscriber> cmd_vel_subs;

    for (size_t i = 0; i < robots.size(); ++i) {
        pose_pubs.push_back(nh.advertise<geometry_msgs::PoseStamped>("/" + robots[i].id + "/pose", 1));
        odom_pubs.push_back(nh.advertise<nav_msgs::Odometry>("/" + robots[i].id + "/odom", 50));

        // Subscriber cmd_vel (override manuale)
        cmd_vel_subs.push_back(nh.subscribe<geometry_msgs::Twist>(
            "/" + robots[i].id + "/cmd_vel", 10,
            boost::bind(&updateCmdVelCallback, _1, &robots[i])
        ));

        ROS_INFO("Robot %s: Pronto.", robots[i].id.c_str());
    }
    
    // SOLO Subscriber per goal globale (unico per tutti i robot)
    ros::Subscriber global_goal_sub = nh.subscribe<geometry_msgs::PoseStamped>(
        "/move_base_simple/goal", 10,
        [&](const geometry_msgs::PoseStamped::ConstPtr& goal_msg){
            ROS_INFO("Goal globale ricevuto (%.2f, %.2f) - assegnato a tutti i robot",
                     goal_msg->pose.position.x, goal_msg->pose.position.y);
            
            for (size_t i = 0; i < robots.size(); ++i) {
                robot_goals[i].has_goal = true;
                robot_goals[i].goal_x = goal_msg->pose.position.x;
                robot_goals[i].goal_y = goal_msg->pose.position.y;
            }
        }
    );

    // Sensori laser - usa LaserScan e LaserScanner
    for (size_t ri = 0; ri < robots.size(); ++ri) {
        for (const auto &s : robots[ri].sensors) {
            if (s.type == "lidar" || s.type == "laser") {
                ActiveSensor as;
                as.cfg = s;
                as.robot_index = ri;
                as.pub = nh.advertise<sensor_msgs::LaserScan>(s.topic, 50);
                as.laser_scan = std::make_shared<LaserScan>(
                    s.range_min, s.range_max, 
                    s.angle_min, s.angle_max, 
                    s.beams
                );
                active_sensors.push_back(as);
                ROS_INFO("Robot %s: Laser pubblicato su %s", 
                         robots[ri].id.c_str(), s.topic.c_str());
            }
        }
    }

    tf2_ros::TransformBroadcaster tf_broadcaster;

    // Trasformata MAP → ODOM
    geometry_msgs::TransformStamped map_to_odom;
    map_to_odom.header.frame_id = "map";
    map_to_odom.child_frame_id = "odom";
    map_to_odom.transform.translation.x = 0.0;
    map_to_odom.transform.translation.y = 0.0;
    map_to_odom.transform.translation.z = 0.0;
    tf2::Quaternion q_identity;
    q_identity.setRPY(0, 0, 0);
    map_to_odom.transform.rotation.x = q_identity.x();
    map_to_odom.transform.rotation.y = q_identity.y();
    map_to_odom.transform.rotation.z = q_identity.z();
    map_to_odom.transform.rotation.w = q_identity.w();

    ros::Rate rate(10);
    float dt = 0.1;
    ROS_INFO("Simulation started. Usa il topic /move_base_simple/goal per inviare goal a TUTTI i robot.");

    int counter = 0;
    while (ros::ok()) {
        ros::Time now = ros::Time::now();

        map_to_odom.header.stamp = now;
        tf_broadcaster.sendTransform(map_to_odom);

        // Simula LaserScan usando grid_map->scanRay (INTERAZIONE CON AMBIENTE)
        for (auto &as : active_sensors) {
            const auto &rob = robots[as.robot_index];

            Isometry2f robot_pose = Isometry2f::Identity();
            robot_pose.translation() = Vector2f(rob.x, rob.y);
            Eigen::Rotation2Df rot(rob.alpha);
            robot_pose.linear() = rot.toRotationMatrix();

            Vector2f sensor_offset(rob.radius, 0);
            Vector2f sensor_global_pos = robot_pose * sensor_offset;

            Isometry2f sensor_pose = robot_pose;
            sensor_pose.translation() = sensor_global_pos;

            float angle_increment = (as.laser_scan->angle_max - as.laser_scan->angle_min) / 
                                   as.laser_scan->ranges.size();

            // INTERAZIONE: Scansiona l'ambiente con il laser
            for (size_t i = 0; i < as.laser_scan->ranges.size(); ++i) {
                float beam_angle = as.laser_scan->angle_min + angle_increment * i;
                Vector2f d(cos(beam_angle), sin(beam_angle));
                d = sensor_pose.linear() * d;

                // Qui il laser INTERAGISCE con l'ambiente tramite scanRay
                as.laser_scan->ranges[i] = grid_map->scanRay(
                    sensor_pose.translation(), 
                    d, 
                    as.laser_scan->range_max
                );
            }

            // Pubblica LaserScan message
            sensor_msgs::LaserScan scan_msg;
            scan_msg.header.stamp = now;
            scan_msg.header.frame_id = as.cfg.frame_id;
            scan_msg.angle_min = as.laser_scan->angle_min;
            scan_msg.angle_max = as.laser_scan->angle_max;
            scan_msg.angle_increment = angle_increment;
            scan_msg.time_increment = 0.0;
            scan_msg.scan_time = dt;
            scan_msg.range_min = as.laser_scan->range_min;
            scan_msg.range_max = as.laser_scan->range_max;
            scan_msg.ranges = as.laser_scan->ranges;

            as.pub.publish(scan_msg);
        }
        
        // VISUALIZZAZIONE: Disegna i raggi laser in RViz
        publishLaserVisualization(laser_viz_pub, active_sensors, robots, now);

        // ===== AGGIORNA CONTROLLO VERSO GOAL =====
        for (size_t i = 0; i < robots.size(); ++i) {
            updateRobotControl(&robots[i], &robot_goals[i]);
        }

        // ===== AGGIORNA CINEMATICA =====
        for (size_t i = 0; i < robots.size(); ++i) { 
            updateUnicycleKinematics(robots[i], dt, grid_map);

            if (counter % 10 == 0) {
                ROS_INFO("Robot %s: pos=(%.2f, %.2f) theta=%.2f vel=(%.2f, %.2f)", 
                         robots[i].id.c_str(), robots[i].x, robots[i].y, robots[i].alpha, 
                         robots[i].current_v_lin, robots[i].current_v_ang);
            }
        }
        counter++;

        map_msg.header.stamp = now;
        map_pub.publish(map_msg);
        publishTF(tf_broadcaster, robots);

        // Pubblica pose e odometry
        for (size_t i = 0; i < robots.size(); ++i) {
            geometry_msgs::PoseStamped p;
            p.header.stamp = now;
            p.header.frame_id = "map";
            p.pose.position.x = robots[i].x;
            p.pose.position.y = robots[i].y;
            p.pose.position.z = 0.0;
            tf2::Quaternion q;
            q.setRPY(0, 0, robots[i].alpha);
            p.pose.orientation.x = q.x();
            p.pose.orientation.y = q.y();
            p.pose.orientation.z = q.z();
            p.pose.orientation.w = q.w();
            pose_pubs[i].publish(p);

            nav_msgs::Odometry odom;
            odom.header.stamp = now;
            odom.header.frame_id = "odom";
            odom.child_frame_id = robots[i].frame_id;
            odom.pose.pose = p.pose;
            odom.twist.twist.linear.x = robots[i].current_v_lin;
            odom.twist.twist.angular.z = robots[i].current_v_ang;
            odom_pubs[i].publish(odom);
        }

        ros::spinOnce();
        rate.sleep();
    }

    return 0;
}